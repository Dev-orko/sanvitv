<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FTP Provider Test</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #1a1a1a;
            color: #fff;
        }
        .test-section {
            background: #2a2a2a;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
            border: 1px solid #444;
        }
        button {
            background: #e50914;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            margin: 5px;
        }
        button:hover {
            background: #f40612;
        }
        .log {
            background: #000;
            padding: 15px;
            border-radius: 6px;
            margin-top: 15px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            max-height: 500px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        .result {
            margin-top: 15px;
            padding: 15px;
            background: #1a3a1a;
            border-radius: 6px;
            border: 1px solid #2a5a2a;
        }
        .error {
            background: #3a1a1a;
            border-color: #5a2a2a;
        }
        input {
            width: 100%;
            padding: 10px;
            font-size: 16px;
            border-radius: 6px;
            border: 1px solid #444;
            background: #1a1a1a;
            color: #fff;
            margin: 10px 0;
        }
        .source-card {
            background: #333;
            padding: 12px;
            margin: 8px 0;
            border-radius: 6px;
            border-left: 4px solid #e50914;
        }
        .score {
            display: inline-block;
            background: #e50914;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <h1>üé¨ FTP Provider Debug Tool</h1>

    <div class="test-section">
        <h2>Test Movie Search</h2>
        <input type="text" id="movieTitle" placeholder="Enter movie title..." value="Mission: Impossible - The Final Reckoning">
        <input type="number" id="movieYear" placeholder="Year (optional)" value="2025">
        <button onclick="testSearch()">Search FTP Directory</button>
        <button onclick="testDirectPath()">Test Direct Path</button>
        <div id="searchLog" class="log"></div>
        <div id="searchResult"></div>
    </div>

    <div class="test-section">
        <h2>Quick Tests</h2>
        <button onclick="testMovie('Mission: Impossible - The Final Reckoning', 2025)">Mission Impossible 2025</button>
        <button onclick="testMovie('Our Fault', 2024)">Our Fault 2024</button>
        <button onclick="testMovie('Fight Club', 1999)">Fight Club 1999</button>
        <button onclick="testMovie('The Shawshank Redemption', 1994)">Shawshank 1994</button>
    </div>

    <script>
        function log(message, type = 'info') {
            const logDiv = document.getElementById('searchLog');
            const timestamp = new Date().toLocaleTimeString();
            const prefix = type === 'error' ? '‚ùå' : type === 'success' ? '‚úÖ' : type === 'warn' ? '‚ö†Ô∏è' : 'üìù';
            logDiv.textContent += `[${timestamp}] ${prefix} ${message}\n`;
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        async function testDirectPath() {
            const resultDiv = document.getElementById('searchResult');
            resultDiv.innerHTML = '';
            document.getElementById('searchLog').textContent = '';

            const directUrl = '/ftp/FTP-2/English%20Movies/2025/Mission-Impossible-The-Final-Reckoning-2025/Mission-Impossible-The-Final-Reckoning-2025-1080p-AMZN-WEB-DL-DDP5-1-Atmos-H-264-BYNDR_reencoded.mp4';
            
            log('Testing direct path access...');
            log('URL: ' + directUrl);

            try {
                const response = await fetch(directUrl, { method: 'HEAD' });
                log(`Response status: ${response.status} ${response.statusText}`, response.ok ? 'success' : 'error');
                log(`Content-Type: ${response.headers.get('content-type')}`);
                log(`Content-Length: ${response.headers.get('content-length')} bytes`);
                
                if (response.ok) {
                    resultDiv.innerHTML = `
                        <div class="result">
                            <h3>‚úÖ Direct Path Accessible</h3>
                            <p>The file exists and can be accessed via proxy!</p>
                            <video controls style="width: 100%; max-width: 800px; margin-top: 10px;">
                                <source src="${directUrl}" type="video/mp4">
                            </video>
                        </div>
                    `;
                } else {
                    resultDiv.innerHTML = `<div class="result error"><h3>‚ùå Direct Path Failed</h3><p>Status: ${response.status}</p></div>`;
                }
            } catch (error) {
                log('Error: ' + error.message, 'error');
                resultDiv.innerHTML = `<div class="result error"><h3>‚ùå Error</h3><p>${error.message}</p></div>`;
            }
        }

        async function testSearch() {
            const title = document.getElementById('movieTitle').value;
            const year = parseInt(document.getElementById('movieYear').value) || undefined;
            await testMovie(title, year);
        }

        async function testMovie(title, year) {
            const resultDiv = document.getElementById('searchResult');
            resultDiv.innerHTML = '<div class="result">Searching...</div>';
            document.getElementById('searchLog').textContent = '';
            
            log(`Searching for: "${title}" ${year ? `(${year})` : ''}`);

            try {
                // Test tokenization
                const normalizeForMatch = (s) => {
                    let out = s;
                    try { out = decodeURIComponent(out); } catch {}
                    return out
                        .toLowerCase()
                        .replace(/[_\.\-]+/g, ' ')
                        .replace(/\([^\)]*\)/g, ' ')
                        .replace(/\[[^\]]*\]/g, ' ')
                        .replace(/[^a-z0-9\s]/g, ' ')
                        .replace(/\s+/g, ' ')
                        .trim();
                };

                const STOP_WORDS = new Set([
                    'the','a','an','of','in','on','at','to','for','with','by','and','or','from','into','over','your','my','is','are','be','this','that','it','as','part','chapter'
                ]);

                const tokenize = (s) => {
                    return normalizeForMatch(s)
                        .split(' ')
                        .filter(t => t.length >= 2 && !STOP_WORDS.has(t));
                };

                const tokens = tokenize(title);
                log(`Query tokens: [${tokens.join(', ')}]`);

                // Fetch root directory
                log('Fetching root directory listing...');
                const rootUrl = '/ftp/FTP-2/English%20Movies/';
                const rootResponse = await fetch(rootUrl);
                
                if (!rootResponse.ok) {
                    throw new Error(`HTTP ${rootResponse.status}: ${rootResponse.statusText}`);
                }

                const rootHtml = await rootResponse.text();
                log(`Root directory fetched (${rootHtml.length} chars)`, 'success');

                // Parse anchors
                const parseAnchors = (html) => {
                    const results = [];
                    const regex = /<a\s+href="([^"]+)">([^<]*)<\/a>/gi;
                    let match;
                    while ((match = regex.exec(html)) !== null) {
                        results.push({ href: match[1], text: match[2] });
                    }
                    return results;
                };

                const anchors = parseAnchors(rootHtml);
                const directories = anchors.filter(a => a.href.endsWith('/') && a.href !== '../');
                const files = anchors.filter(a => /\.(mp4|mkv|webm|avi|mov|m4v)$/i.test(a.href));

                log(`Found ${directories.length} directories and ${files.length} files at root`);

                // Score matches
                const scoreMatch = (queryTokens, candidateTokens) => {
                    if (candidateTokens.length === 0 || queryTokens.length === 0) return 0;
                    const cset = new Set(candidateTokens);
                    const qset = new Set(queryTokens);
                    let intersect = 0;
                    for (const q of qset) if (cset.has(q)) intersect++;

                    let score = intersect / qset.size;

                    const candJoined = candidateTokens.join(' ');
                    const queryJoined = queryTokens.join(' ');
                    if (candJoined.includes(queryJoined)) score += 0.5;
                    const lenDiff = Math.abs(candidateTokens.length - queryTokens.length);
                    score += Math.max(0, 0.3 - lenDiff * 0.05);

                    return score;
                };

                // Check if year is in path
                const yearStr = year ? String(year) : (/\b(19\d{2}|20\d{2})\b/.exec(title) || [])[1];
                log(`Year to match: ${yearStr || 'none'}`);

                // Look for year directory
                if (yearStr) {
                    const yearDir = directories.find(d => d.href === `${yearStr}/`);
                    if (yearDir) {
                        log(`Found year directory: ${yearStr}/`, 'success');
                        const yearDirUrl = rootUrl + yearDir.href;
                        const yearResponse = await fetch(yearDirUrl);
                        
                        if (yearResponse.ok) {
                            const yearHtml = await yearResponse.text();
                            const yearAnchors = parseAnchors(yearHtml);
                            const yearDirs = yearAnchors.filter(a => a.href.endsWith('/') && a.href !== '../');
                            
                            log(`Year directory has ${yearDirs.length} subdirectories`);

                            // Score each subdirectory
                            const scoredDirs = yearDirs.map(d => {
                                const display = decodeURIComponent(d.href);
                                const candTokens = tokenize(display);
                                const score = scoreMatch(tokens, candTokens);
                                return { d, score, display };
                            }).sort((a, b) => b.score - a.score);

                            if (scoredDirs.length > 0) {
                                log(`Top matching subdirectory: ${scoredDirs[0].display} (score: ${scoredDirs[0].score.toFixed(3)})`);

                                // Fetch the top directory
                                const topDirUrl = yearDirUrl + scoredDirs[0].d.href;
                                const topDirResponse = await fetch(topDirUrl);

                                if (topDirResponse.ok) {
                                    const topDirHtml = await topDirResponse.text();
                                    const topDirAnchors = parseAnchors(topDirHtml);
                                    const videoFiles = topDirAnchors.filter(a => /\.(mp4|mkv|webm|avi|mov|m4v)$/i.test(a.href));

                                    log(`Found ${videoFiles.length} video files in ${scoredDirs[0].display}`, 'success');

                                    if (videoFiles.length > 0) {
                                        resultDiv.innerHTML = '<div class="result"><h3>‚úÖ Found Video Files</h3></div>';
                                        
                                        videoFiles.forEach((file, idx) => {
                                            const fileName = decodeURIComponent(file.href);
                                            const fileUrl = topDirUrl + file.href;
                                            const quality = (/2160p|4k/i.test(fileName) ? '2160p' : 
                                                           /1080p/i.test(fileName) ? '1080p' : 
                                                           /720p/i.test(fileName) ? '720p' : 
                                                           /480p/i.test(fileName) ? '480p' : 'Unknown');

                                            const card = document.createElement('div');
                                            card.className = 'source-card';
                                            card.innerHTML = `
                                                <div><strong>#${idx + 1}</strong> ${fileName}</div>
                                                <div style="margin-top: 8px;">
                                                    <span class="score">${quality}</span>
                                                    <button onclick="playVideo('${fileUrl.replace(/'/g, "\\'")}', '${fileName.replace(/'/g, "\\'")}')">‚ñ∂ Play</button>
                                                    <button onclick="testFile('${fileUrl.replace(/'/g, "\\'")}')">üîç Test</button>
                                                </div>
                                            `;
                                            resultDiv.appendChild(card);
                                        });
                                        return;
                                    }
                                }
                            }
                        }
                    }
                }

                resultDiv.innerHTML = '<div class="result error"><h3>‚ùå No Files Found</h3><p>Try testing the direct path or check the title/year.</p></div>';
                
            } catch (error) {
                log('Error: ' + error.message, 'error');
                resultDiv.innerHTML = `<div class="result error"><h3>‚ùå Error</h3><p>${error.message}</p></div>`;
            }
        }

        function playVideo(url, name) {
            const resultDiv = document.getElementById('searchResult');
            resultDiv.innerHTML = `
                <div class="result">
                    <h3>üé¨ Playing: ${name}</h3>
                    <video controls autoplay style="width: 100%; max-width: 800px; margin-top: 10px;">
                        <source src="${url}" type="video/mp4">
                    </video>
                </div>
            `;
        }

        async function testFile(url) {
            log(`Testing file: ${url}`);
            try {
                const response = await fetch(url, { method: 'HEAD' });
                log(`Response: ${response.status} ${response.statusText}`, response.ok ? 'success' : 'error');
                log(`Content-Type: ${response.headers.get('content-type')}`);
                log(`Content-Length: ${response.headers.get('content-length')} bytes`);
            } catch (error) {
                log('Error: ' + error.message, 'error');
            }
        }

        // Run initial test
        window.addEventListener('load', () => {
            log('FTP Provider Debug Tool Ready');
            log('Click a test button or enter a custom title');
        });
    </script>
</body>
</html>
